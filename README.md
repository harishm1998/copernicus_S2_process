Detailed Documentation: Sentinel-2 Image ProcessorThis document provides an in-depth look into the Sentinel-2 Image Processor, covering its fundamental concepts, architectural design, development lifecycle, deployment considerations, and extensibility.1. Core IdeaThe primary goal of the Sentinel-2 Image Processor is to provide a flexible and efficient command-line tool for performing common geospatial operations on Sentinel-2 Level-2A satellite imagery. Sentinel-2 data is typically distributed in large .zip archives containing numerous spectral bands and metadata. Processing these archives often involves several steps: decompression, identifying specific bands, and applying mathematical or filtering operations.The core idea behind this processor is to streamline this workflow and, crucially, to enable extensibility through a plugin architecture. This means that new image processing algorithms or "operations" can be developed, compiled into separate shared libraries, and then dynamically loaded by the main application at runtime. This approach avoids the need to recompile the entire core application every time a new operation is introduced, fostering modularity, maintainability, and ease of deployment for new functionalities.2. MethodologyThe processor follows a well-defined methodology to achieve its objectives:Input Acquisition & Decompression:The application takes the path to a Sentinel-2 .SAFE.zip archive as input.It utilizes the minizip-ng library to perform in-memory decompression of the archive into a temporary directory on the filesystem. This ensures that the raw image files are accessible for GDAL.Band Discovery and Prioritization:Once extracted, the application recursively traverses the .SAFE directory structure.It identifies all .jp2 (JPEG 2000) or .tif files that conform to Sentinel-2 band naming conventions (e.g., _B04_, _B08_, _B8A_) and are located within the IMG_DATA subdirectory.Crucially, Sentinel-2 provides certain bands at multiple resolutions (10m, 20m, 60m). The band discovery logic prioritizes the highest available resolution for each band (10m > 20m > 60m) to ensure optimal data quality for calculations.Metadata (dimensions, data type, projection, geotransform) for each discovered band is extracted using GDAL and logged.Operation Execution (Plugin-Driven):The user specifies an operation name (e.g., NDVI) and any required arguments via command-line.The application dynamically loads shared libraries (.so files) from a designated plugins/ directory.Each loaded plugin is expected to export specific C-compatible factory functions (createOperationInstance, getOperationName) that allow the main application to instantiate an IOperation object and query its name.The S2Processor then looks up the requested operation name among its registered plugins.If found, it invokes the execute() method on the corresponding IOperation object, passing the paths to the discovered bands, operation-specific arguments, and the desired output file path.The operation module performs the pixel-wise calculations and writes the result to the specified output GeoTIFF file, preserving georeferencing information from the input bands.3. DesignThe design of the Sentinel-2 Image Processor is centered around modularity, extensibility, and leveraging established geospatial libraries.3.1. Architectural Pattern: Plugin ArchitectureThe core design pattern is a Plugin Architecture. This is achieved through:IOperation Interface: An abstract base class defining a common contract (getName(), execute()) for all image processing operations. This ensures that any new operation, regardless of its internal logic, presents a consistent interface to the S2Processor.Dynamic Loading (dlfcn.h): The s2_processor executable uses dlopen(), dlsym(), and dlclose() to load shared libraries (.so files) at runtime. This is the mechanism by which plugins are integrated.C-Compatible Factory Functions (extern "C"): To avoid C++ name mangling issues when dynamically loading, each plugin exports specific functions (createOperationInstance(), getOperationName()) with extern "C" linkage. These functions act as "factories" to create instances of IOperation implementations within the plugin.std::unique_ptr for Ownership: std::unique_ptr is used to manage the lifetime of IOperation objects created by plugins, ensuring proper memory deallocation when the operations are no longer needed.3.2. Core Components & Responsibilitiess2_processor.cpp (Main Application):Orchestration: Manages the overall processing flow.Plugin Management: Discovers, loads, registers, and unloads plugins.Input/Output Handling: Parses command-line arguments, manages temporary directories.GDAL Initialization/Cleanup: Handles global GDAL registration and driver manager destruction.MinizipExtractor Class:Encapsulation: Handles all concerns related to .zip file decompression.Temporary File Management: Creates and manages temporary directories for extracted data.IOperation.h:Contract Definition: Defines the interface for all pluggable operations. This is the crucial abstraction layer.OperationFactory.h:Type Safety: Provides typedefs for the C-compatible factory function pointers, improving code readability and type safety in s2_processor.cpp's dynamic loading logic.NdviOperation.h/NdviOperation.cpp (Example Plugin):Concrete Implementation: Provides a specific image processing algorithm (NDVI) that adheres to the IOperation interface.Self-Contained Logic: Contains all necessary logic and dependencies for its specific operation.Factory Export: Exports the extern "C" factory functions for dynamic loading.Helper Functions (readBandToFloat, writeOutputTiff):Utility Layer: Provide common, reusable functionalities for reading and writing raster data using GDAL. These are currently part of s2_processor.cpp but could be refactored into a separate utility library for larger projects.3.3. External LibrariesGDAL (Geospatial Data Abstraction Library):Core Geospatial Processing: Used for reading and writing various raster formats (especially .jp2 and GeoTIFF), accessing band data, and handling georeferencing information (projections, geotransforms).Error Handling: Integrated with a custom GDAL error handler for consistent logging.Minizip-ng:Zip Decompression: Provides the necessary API for programmatic extraction of .zip archives.std::filesystem (C++20):Filesystem Operations: Used for cross-platform directory creation, path manipulation, and iterating through directory contents, simplifying file system interactions.4. Development FlowThe development flow is designed to be efficient for both core application development and plugin creation.Set Up Environment:Ensure all prerequisites (compiler, GDAL, Minizip-ng, etc.) are installed and correctly configured in your system's PATH and library paths.Core Application Development:Work on s2_processor.cpp, IOperation.h, OperationFactory.h.Compile s2_processor.cpp into the main executable.Plugin Development:For each new operation:Create MyNewOperation.h and MyNewOperation.cpp.Implement the IOperation interface.Add the extern "C" factory functions.Crucially, compile the plugin independently into a shared library (.so file).Testing:Place the compiled .so files into the plugins/ directory.Run the s2_processor executable with sample Sentinel-2 data and specify the new operation.Debug plugins using standard debugging tools (e.g., GDB) which can attach to dynamically loaded libraries.Iteration:Changes to a plugin only require recompiling that specific plugin's .cpp file into its .so and replacing it in the plugins/ directory. The main s2_processor executable does not need to be recompiled. This significantly speeds up development cycles for new features.5. DeploymentDeploying the Sentinel-2 Image Processor involves ensuring the executable and its dependencies are correctly placed on the target system.Compile on Target System (Recommended):The most robust approach is to compile the s2_processor executable and all desired plugins directly on the target deployment environment. This ensures compatibility with the system's specific GDAL, Minizip-ng, and C++ runtime versions.Package Executable and Plugins:The s2_processor executable.The plugins/ directory containing all necessary .so files (e.g., libndvi_op.so).Ensure Library Dependencies:The GDAL library and its dependencies (Minizip-ng, libxml2, etc.) must be installed on the target system. Ensure their shared libraries are discoverable by the system's dynamic linker (e.g., in /usr/local/lib, /usr/lib, or paths specified in LD_LIBRARY_PATH).Provide Input Data:The Sentinel-2 .SAFE.zip archives must be accessible to the application.6. DocumentationThis project adheres to a self-documenting principle, providing comprehensive information at various levels:GitHub README (README.md): A high-level overview for quick understanding, covering features, project structure, prerequisites, building instructions, basic usage examples, and contribution guidelines. This is the first point of contact for new users.Detailed Documentation (This Document): Provides in-depth explanations of the core idea, methodology, architectural design, development workflow, deployment, and extensibility, crucial for developers and advanced users.Inline Code Comments: Extensive comments within the C++ source files explain specific logic, algorithms, class responsibilities, and function parameters. This is vital for code maintainability and understanding.Command-Line Usage Output: The application itself provides a clear usage message if invoked incorrectly, detailing available operations and their arguments.7. Modifying the ProjectModifying the project can involve changes to the core application or extending its functionality with new operations.7.1. Modifying Core Logic (s2_processor.cpp)Purpose: Changes to how plugins are loaded, how bands are discovered, or how the overall pipeline is orchestrated.Process:Edit s2_processor.cpp (and potentially IOperation.h, OperationFactory.h if the interface changes).Recompile s2_processor.cpp (only the main executable).Test the updated core functionality.7.2. Adding New Operations (Plugins)This is the primary way to extend the processor's capabilities. Refer to Section 4 ("Development Flow") and Section 9 ("Added Calculation Modules") for detailed steps. The key advantage here is that the core s2_processor executable does not need to be recompiled.8. CompilationCompilation involves two distinct steps: building the main executable and building each plugin as a shared library.8.1. Main Executable Compilationg++ -std=c++20 -lstdc++fs \
  -I. \
  -I/usr/local/include/minizip \
  $(gdal-config --cflags) \
  s2_processor.cpp \
  -o s2_processor \
  -lminizip \
  $(pkg-config --libs libxml-2.0) -llzma -lz \
  -lproj -lgeos_c -lsqlite3 -lcurl \
  -lgdal -lpthread -ldl -lm
-std=c++20: Enables C++20 features.-lstdc++fs: Links the C++ filesystem library.-I.: Includes the current directory for headers like IOperation.h.-I/usr/local/include/minizip: Specifies the path to Minizip-ng headers (adjust if different).$(gdal-config --cflags): Injects necessary GDAL compilation flags.s2_processor.cpp: The source file for the main application.-o s2_processor: Output executable name.-lminizip: Links the Minizip-ng library.$(pkg-config --libs libxml-2.0) -llzma -lz -lproj -lgeos_c -lsqlite3 -lcurl: Links common GDAL dependencies.-lgdal: Links the GDAL library.-lpthread -ldl -lm: Links POSIX threads, dynamic loading library (dlopen, dlsym), and math library.8.2. Plugin Compilation (Example: NdviOperation)g++ -std=c++20 -fPIC -shared \
  -I. \
  -I/usr/local/include/minizip \
  $(gdal-config --cflags) \
  NdviOperation.cpp \
  -o plugins/libndvi_op.so \
  -lminizip \
  $(pkg-config --libs libxml-2.0) -llzma -lz \
  -lproj -lgeos_c -lsqlite3 -lcurl \
  -lgdal -lpthread -ldl -lm
-fPIC: Generates Position-Independent Code, mandatory for shared libraries.-shared: Creates a shared library (.so file).-I.: Includes the current directory for headers like IOperation.h and NdviOperation.h.-o plugins/libndvi_op.so: Specifies the output path and name for the shared library. It must be placed in the plugins/ directory for the main application to find it.Note: Plugins also need to link against any libraries they use (GDAL, Minizip-ng, etc.) because they are compiled as independent modules.9. Added Calculation ModulesCurrently, the project includes one primary calculation module as a dynamically loadable plugin:9.1. NDVI (Normalized Difference Vegetation Index)Name: NDVIFormula: NDVI=(NIRâˆ’RED)/(NIR+RED)Required Arguments:<NIR_band_name>: The name of the Near-Infrared band (typically B08 for Sentinel-2).<RED_band_name>: The name of the Red band (typically B04 for Sentinel-2).Implementation: Handled by the NdviOperation class, compiled into libndvi_op.so.Example Usage:./s2_processor S2A_MSIL2A_...SAFE.zip output_ndvi.tif NDVI B08 B04
9.2. How to Add More Calculation ModulesTo add new operations like ADD, SUB, or FILTER, you would follow the plugin development process outlined in Section 4 and Section 7.2.For example, to add an ADD operation:AddOperation.h:#pragma once
#include "IOperation.h"
// ... include necessary helpers and GDAL forward declarations ...
class AddOperation : public IOperation {
public:
    std::string getName() const override { return "ADD"; }
    bool execute(const std::map<std::string, std::string>& bandPaths,
                 const std::vector<std::string>& args,
                 const std::string& outputPath) override;
};
AddOperation.cpp:#include "AddOperation.h"
#include <iostream>
// ... include necessary GDAL headers and helper function re-declarations ...

bool AddOperation::execute(const std::map<std::string, std::string>& bandPaths,
                           const std::vector<std::string>& args,
                           const std::string& outputPath) {
    // ... implementation of band addition (band1 + band2) ...
    // Use readBandToFloat and writeOutputTiff
    return true; // or false on error
}

extern "C" std::unique_ptr<IOperation> createOperationInstance() {
    return std::make_unique<AddOperation>();
}

extern "C" const char* getOperationName() {
    return "ADD";
}
Compile:g++ -std=c++20 -fPIC -shared \
  -I. \
  -I/usr/local/include/minizip \
  $(gdal-config --cflags) \
  AddOperation.cpp \
  -o plugins/libadd_op.so \
  -lminizip \
  $(pkg-config --libs libxml-2.0) -llzma -lz \
  -lproj -lgeos_c -lsqlite3 -lcurl \
  -lgdal -lpthread -ldl -lm
Run:./s2_processor S2A_MSIL2A_...SAFE.zip output_sum.tif ADD B04 B03
This systematic approach ensures that the project remains scalable and easy to manage as more image processing functionalities are added.
